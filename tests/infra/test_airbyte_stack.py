import pytest
from aws_cdk import App, Stack, assertions
from infra.stacks.data.airbyte_stack import AirbyteStack
from aws_cdk import aws_ec2 as ec2

class DummyVpc(ec2.Vpc):
    def __init__(self, scope, id):
        super().__init__(scope, id, max_azs=1)

@pytest.fixture
def airbyte_config():
    return {
        "app": {"env": "test"},
        "airbyte": {
            "instance_type": "t3.medium",
            "desired_count": 1
        }
    }

# --- Happy path: Outputs ---
def test_airbyte_stack_outputs(airbyte_config):
    app = App()
    test_stack = Stack(app, "TestStack")
    vpc = DummyVpc(test_stack, "DummyVpc")
    stack = AirbyteStack(app, "TestAirbyteStack", vpc=vpc, config=airbyte_config)
    template = assertions.Template.from_stack(stack)
    outputs = template.to_json().get("Outputs", {})
    # Check for exact output keys as generated by the stack
    assert "TestAirbyteStackAirbyteALBDns" in outputs
    assert "TestAirbyteStackAirbyteServiceName" in outputs
    assert "TestAirbyteStackAirbyteLogGroupName" in outputs
    assert "TestAirbyteStackAirbyteTaskFailureAlarmArn" in outputs
    assert "TestAirbyteStackAirbyteAlb5xxAlarmArn" in outputs
    # Shared resources dict exposes all key constructs
    assert hasattr(stack, "shared_resources")
    for key in ["cluster", "service", "alb", "log_group", "task_alarm", "alb_5xx_alarm"]:
        assert key in stack.shared_resources

# --- Happy path: Secret injection ---
def test_airbyte_stack_secret_injection(monkeypatch, airbyte_config):
    app = App()
    test_stack = Stack(app, "TestStack")
    vpc = DummyVpc(test_stack, "DummyVpc")
    from aws_cdk import aws_secretsmanager as secretsmanager
    secret = secretsmanager.Secret(test_stack, "DummySecret")
    config = airbyte_config.copy()
    config["airbyte"]["db_secret_arn"] = secret.secret_arn
    stack = AirbyteStack(app, "TestAirbyteStack", vpc=vpc, config=config)
    template = assertions.Template.from_stack(stack)
    resources = template.find_resources("AWS::ECS::TaskDefinition")
    found = False
    for td in resources.values():
        container_defs = td["Properties"].get("ContainerDefinitions", [])
        for cdef in container_defs:
            if "Secrets" in cdef:
                found = True
    assert found

# --- Happy path: Monitoring outputs ---
def test_airbyte_stack_monitoring_outputs(airbyte_config):
    app = App()
    test_stack = Stack(app, "TestStack")
    vpc = DummyVpc(test_stack, "DummyVpc")
    stack = AirbyteStack(app, "TestAirbyteStack", vpc=vpc, config=airbyte_config)
    # Monitoring resources present
    assert hasattr(stack, "ecs_task_alarm")
    assert hasattr(stack, "alb_5xx_alarm")
    assert stack.ecs_task_alarm.alarm_arn is not None
    assert stack.alb_5xx_alarm.alarm_arn is not None
    # Shared resources dict exposes alarms
    assert stack.shared_resources["task_alarm"] == stack.ecs_task_alarm
    assert stack.shared_resources["alb_5xx_alarm"] == stack.alb_5xx_alarm

# --- Happy path: Health check config ---
def test_airbyte_stack_health_check_config():
    app = App()
    test_stack = Stack(app, "TestStack")
    vpc = DummyVpc(test_stack, "DummyVpc")
    config = {
        "airbyte": {
            "instance_type": "t3.medium",
            "desired_count": 1,
            "health_check_path": "/custom/health",
            "health_check_codes": "200-299"
        }
    }
    stack = AirbyteStack(app, "TestAirbyteStack", vpc=vpc, config=config)
    template = assertions.Template.from_stack(stack)
    resources = template.find_resources("AWS::ElasticLoadBalancingV2::TargetGroup")
    assert any(
        r["Properties"].get("HealthCheckPath") == "/custom/health" and
        r["Properties"].get("HealthCheckHealthyHttpCodes") == "200-299"
        for r in resources.values()
    )

# --- Happy path: Security group ingress config ---
def test_airbyte_stack_allowed_cidr():
    app = App()
    test_stack = Stack(app, "TestStack")
    vpc = DummyVpc(test_stack, "DummyVpc")
    config = {
        "app": {"env": "test"},
        "airbyte": {
            "instance_type": "t3.medium",
            "desired_count": 1,
            "allowed_cidr": "10.0.0.0/16"
        }
    }
    stack = AirbyteStack(app, "TestAirbyteStack", vpc=vpc, config=config)
    template = assertions.Template.from_stack(stack)
    resources = template.find_resources("AWS::EC2::SecurityGroup")
    found = False
    for sg in resources.values():
        ingress = sg["Properties"].get("SecurityGroupIngress", [])
        for rule in ingress:
            if rule.get("CidrIp") == "10.0.0.0/16":
                found = True
    assert found, f"Expected CIDR not found in ingress rules."

# --- Unhappy path: Invalid cpu/memory ---
@pytest.mark.parametrize("bad_config", [
    {"airbyte": {"instance_type": "t3.medium", "desired_count": 1, "cpu": 128}},
    {"airbyte": {"instance_type": "t3.medium", "desired_count": 1, "memory": 128}},
])
def test_airbyte_stack_invalid_cpu_memory(bad_config):
    app = App()
    test_stack = Stack(app, "TestStack")
    vpc = DummyVpc(test_stack, "DummyVpc")
    with pytest.raises(ValueError):
        AirbyteStack(app, "TestAirbyteStack", vpc=vpc, config=bad_config)
# --- Happy path: Minimal config ---
def test_airbyte_stack_minimal_config():
    app = App()
    test_stack = Stack(app, "TestStack")
    vpc = DummyVpc(test_stack, "DummyVpc")
    minimal_config = {"airbyte": {}}
    stack = AirbyteStack(app, "TestAirbyteStack", vpc=vpc, config=minimal_config)
    assert hasattr(stack, "cluster")

# --- Happy path: Environment-specific config ---
import copy
import pytest
@pytest.mark.parametrize("env", ["dev", "staging", "prod"])
def test_airbyte_stack_env_config(env):
    app = App()
    test_stack = Stack(app, "TestStack")
    vpc = DummyVpc(test_stack, "DummyVpc")
    config = {"app": {"env": env}, "airbyte": {"instance_type": "t3.medium", "desired_count": 1}}
    stack = AirbyteStack(app, "TestAirbyteStack", vpc=vpc, config=config)
    assert hasattr(stack, "cluster")

# --- Unhappy path: Unknown config keys (should not raise) ---
def test_airbyte_stack_unknown_config_keys():
    app = App()
    test_stack = Stack(app, "TestStack")
    vpc = DummyVpc(test_stack, "DummyVpc")
    config = {"app": {"env": "test"}, "airbyte": {"instance_type": "t3.medium", "desired_count": 1, "unknown_key": 123}}
    stack = AirbyteStack(app, "TestAirbyteStack", vpc=vpc, config=config)
    assert hasattr(stack, "cluster")

# --- Happy path: Tagging (if implemented) ---
def test_airbyte_stack_tags(airbyte_config):
    app = App()
    test_stack = Stack(app, "TestStack")
    vpc = DummyVpc(test_stack, "DummyVpc")
    stack = AirbyteStack(app, "TestAirbyteStack", vpc=vpc, config=airbyte_config)
    tags = stack.tags.render_tags()
    assert any(tag.get("Key") == "Project" and tag.get("Value") == "ShieldCraftAI" for tag in tags)


# --- Happy path: Synthesis and resource count ---
def test_airbyte_stack_synthesizes(airbyte_config):
    app = App()
    test_stack = Stack(app, "TestStack")
    vpc = DummyVpc(test_stack, "DummyVpc")
    stack = AirbyteStack(app, "TestAirbyteStack", vpc=vpc, config=airbyte_config)
    template = assertions.Template.from_stack(stack)
    template.resource_count_is("AWS::ECS::Cluster", 1)

# --- Happy path: ECS Cluster and Security Group properties ---
def test_airbyte_cluster_vpc_association(airbyte_config):
    app = App()
    test_stack = Stack(app, "TestStack")
    vpc = DummyVpc(test_stack, "DummyVpc")
    stack = AirbyteStack(app, "TestAirbyteStack", vpc=vpc, config=airbyte_config)
    assert stack.cluster.vpc == vpc

def test_airbyte_security_group_properties(airbyte_config):
    app = App()
    test_stack = Stack(app, "TestStack")
    vpc = DummyVpc(test_stack, "DummyVpc")
    stack = AirbyteStack(app, "TestAirbyteStack", vpc=vpc, config=airbyte_config)
    sg = [c for c in stack.node.children if isinstance(c, ec2.SecurityGroup)]
    assert sg, "SecurityGroup not created"
    assert sg[0].allow_all_outbound is True

# --- Happy path: DB Secret optionality ---
def test_airbyte_stack_with_db_secret(monkeypatch, airbyte_config):
    app = App()
    test_stack = Stack(app, "TestStack")
    vpc = DummyVpc(test_stack, "DummyVpc")
    from aws_cdk import aws_secretsmanager as secretsmanager
    secret = secretsmanager.Secret(test_stack, "DummySecret2")
    config = airbyte_config.copy()
    config["airbyte"]["db_secret_arn"] = secret.secret_arn
    stack = AirbyteStack(app, "TestAirbyteStack", vpc=vpc, config=config)
    assert hasattr(stack, "cluster")

# --- Unhappy path: Missing VPC ---
def test_airbyte_stack_missing_vpc_raises(airbyte_config):
    app = App()
    with pytest.raises(AssertionError):
        AirbyteStack(app, "TestAirbyteStack", vpc=None, config=airbyte_config)

# --- Unhappy path: Invalid config values ---
@pytest.mark.parametrize("bad_config", [
    {"app": {"env": "test"}, "airbyte": {"instance_type": "t3.medium", "desired_count": -1}},
])
def test_airbyte_stack_invalid_config(bad_config):
    app = App()
    test_stack = Stack(app, "TestStack")
    vpc = DummyVpc(test_stack, "DummyVpc")
    import pytest
    with pytest.raises(ValueError):
        AirbyteStack(app, "TestAirbyteStack", vpc=vpc, config=bad_config)

# --- Unhappy path: Invalid secret ARN ---
def test_airbyte_stack_invalid_secret_arn(monkeypatch, airbyte_config):
    app = App()
    test_stack = Stack(app, "TestStack")
    vpc = DummyVpc(test_stack, "DummyVpc")
    config = airbyte_config.copy()
    config["airbyte"]["db_secret_arn"] = "invalid-arn"
    def raise_exc(*a, **k):
        raise ValueError("Invalid ARN")
    monkeypatch.setattr(
        "aws_cdk.aws_secretsmanager.Secret.from_secret_complete_arn",
        raise_exc
    )
    with pytest.raises(ValueError):
        AirbyteStack(app, "TestAirbyteStack", vpc=vpc, config=config)


# --- Supplementary: Outputs (ALB DNS, ECS Service Name, Log Group) ---
def test_airbyte_stack_outputs(airbyte_config):
    app = App()
    test_stack = Stack(app, "TestStack")
    vpc = DummyVpc(test_stack, "DummyVpc")
    stack = AirbyteStack(app, "TestAirbyteStack", vpc=vpc, config=airbyte_config)
    template = assertions.Template.from_stack(stack)
    # Duplicate/loose output test removed as strict key test above is sufficient


# --- Supplementary: Secret injection into ECS task definition ---
def test_airbyte_stack_secret_env(monkeypatch, airbyte_config):
    app = App()
    test_stack = Stack(app, "TestStack")
    vpc = DummyVpc(test_stack, "DummyVpc")
    config = airbyte_config.copy()
    config["airbyte"]["db_secret_arn"] = "arn:aws:secretsmanager:us-east-1:123456789012:secret:dummy"
    # Patch Secret.from_secret_complete_arn to avoid AWS call
    from aws_cdk import aws_secretsmanager as secretsmanager
    secret = secretsmanager.Secret(test_stack, "DummySecret3")
    config = airbyte_config.copy()
    config["airbyte"]["db_secret_arn"] = secret.secret_arn
    stack = AirbyteStack(app, "TestAirbyteStack", vpc=vpc, config=config)
    template = assertions.Template.from_stack(stack)
    resources = template.find_resources("AWS::ECS::TaskDefinition")
    found = False
    for td in resources.values():
        container_defs = td["Properties"].get("ContainerDefinitions", [])
        for cdef in container_defs:
            secrets = cdef.get("Secrets", [])
            print(f"DEBUG: ContainerDefinition Secrets: {secrets}")
            if any(s.get("Name") == "AIRBYTE_DB_SECRET" for s in secrets):
                found = True
    assert found, "AIRBYTE_DB_SECRET not found in ECS container secrets."


# --- Supplementary: Health check config ---
def test_airbyte_stack_health_check_config():
    app = App()
    test_stack = Stack(app, "TestStack")
    vpc = DummyVpc(test_stack, "DummyVpc")
    config = {
        "app": {"env": "test"},
        "airbyte": {
            "instance_type": "t3.medium",
            "desired_count": 1,
            "health_check_path": "/custom/health",
            "health_check_codes": "200-299"
        }
    }
    stack = AirbyteStack(app, "TestAirbyteStack", vpc=vpc, config=config)
    # Find the ALB and listener
    alb = stack.alb
    listeners = [c for c in alb.node.children if hasattr(c, "add_targets")]
    assert listeners, "No ALB listener found"
    # We can't directly inspect the health check, but we can check the synthesized template
    template = assertions.Template.from_stack(stack)
    resources = template.to_json().get("Resources", {})
    # Find the TargetGroup and check HealthCheckPath and Matcher
    tg = [v for v in resources.values() if v["Type"] == "AWS::ElasticLoadBalancingV2::TargetGroup"]
    assert tg, "No TargetGroup found"
    props = tg[0]["Properties"]
    assert props["HealthCheckPath"] == "/custom/health"
    assert props["Matcher"]["HttpCode"] == "200-299"


# --- Supplementary: Security group ingress (allowed CIDR) ---
def test_airbyte_stack_allowed_cidr():
    app = App()
    test_stack = Stack(app, "TestStack")
    vpc = DummyVpc(test_stack, "DummyVpc")
    config = {
        "app": {"env": "test"},
        "airbyte": {
            "instance_type": "t3.medium",
            "desired_count": 1,
            "allowed_cidr": "10.0.0.0/16"
        }
    }
    stack = AirbyteStack(app, "TestAirbyteStack", vpc=vpc, config=config)
    template = assertions.Template.from_stack(stack)
    resources = template.find_resources("AWS::EC2::SecurityGroup")
    found = False
    for sg in resources.values():
        ingress = sg["Properties"].get("SecurityGroupIngress", [])
    for rule in ingress:
        if rule.get("CidrIp") == "10.0.0.0/16":
            found = True
    assert found


# --- Supplementary: Unhappy path for invalid cpu/memory ---
import pytest
import copy
@pytest.mark.parametrize("cpu,memory", [
    (128, 2048),  # cpu too low
    (1024, 256),  # memory too low
    ("bad", 2048),  # cpu not int
    (1024, "bad"),  # memory not int
])
def test_airbyte_stack_invalid_cpu_memory(cpu, memory, airbyte_config):
    app = App()
    test_stack = Stack(app, "TestStack")
    vpc = DummyVpc(test_stack, "DummyVpc")
    config = copy.deepcopy(airbyte_config)
    config["airbyte"]["cpu"] = cpu
    config["airbyte"]["memory"] = memory
    with pytest.raises(ValueError):
        AirbyteStack(app, "TestAirbyteStack", vpc=vpc, config=config)
